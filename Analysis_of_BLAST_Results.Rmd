---
title: "Analysis of BLAST Results"
author: "Emre Ovet"
date: "October 12, 2018"
output: github_document
---

# Introduction

The human skin contains a large amount of bacteria on its surface due to its constact contact with air and different objects in daily life. Those bacterial communities are able to survive on skin surface for long periods of time because most of them are highly resistant to to environmental stress factors like temperature and UV, thus, skin surface is a favorable habitat for them. 

According to the recent studies, it is found out that the diversity of bacterial communities on palm surface is much higher than what is previously assumed and that after washing hands, the  surviving bacteria are able to reproduce rapidly and recover their previous population. It is also found out that the genera of bacteria living on the palm surface largely varies between individuals.

In the light of these information, we hypothesize that the specificity of the bacterial community genera can be used for forensic investigatigation by comparing the bacteria found on different objects with those found on the palm surfaces of individuals. In order to test our hypothesis, we conducted an experiment in which bacterial communities from keyboards and computer mouses were extracted along with those from the palm surfaces of individuals using those equipment, then the genera of the bacteria from keyboards and computer mouses were compared with those from skin surfaces using pyrosequencing. 

# Methods

## Sample origin and sequencing

For the keyboard analysis, keys from 3 personal computer keyboards were swabbed along with the fingertips of their owners. Then, space bar keys from 15 personal or public computer keyboards located in University of Colorado Campus were swabbed. In order to sample skin surfaces and keyboards, pre- moistured and autoclaved cotton-tipped swabs were used.

For the storage analysis, right axillary skin surface of 2 adults were sampled by 16 moistened swabs per individual. Half of these swabs were frozen at -20째C and the other half left in uncapped 15 ml conical tubes on the laboratory bench that is in indoor conditions at ~20째C and fluorescent lighting applied to samples ~8 hours per day. Finally, bacterial DNA was extracted from the samples which were kept at ~ -80째C.

For the computer mouse analysis, the palm surfaces of 4 men and 4 women from University of Colorado campus were swabbed along with the computer mouses of each individual's personal computer which were last touched by their owners 12 hours before the swabbing. All swabs were stored in -80째C until the DNA extraction. Then, the database of bacterial communities from both the right and left hand palm surfaces of 270 other individuals were compiled, sampled and analyzed.

For the pyrosequencing, DNA was extracted from samples by using MO BIO Powersoil DNA isolation kit. Amplicons were cleaned using the UltraClean-htp 96-well PCR Clean-up kit and the DNA concentration inside the amplicon were measured using the Quant-iT PicoGreen dsDNA reagent and kit. 

## Computational

On a tmux session, QC reports were created using the data from NCBI using FastQC program. Then, we used the Cyberduck program to transfer the files from tmux to our computer. After then, we trimed the sequences by looking at their quality scores, that is, any sequence below 150 base pairs were filtered. Furthermore, we  Blasted the sequences to obtain the top match of each sequence.Finally, we used dplyr functions to visualize our data on Rstudio by making plots.



# Results

```{r load-libraries, message = FALSE}
# Be sure to install these packages before running this script
# They can be installed either with the install.packages() function
# or with the 'Packages' pane in RStudio

# load packages
library("dplyr")
library("tidyr")
library("knitr")
library("ggplot2")
```

```{r make-read-in-data-function}
# Output format from BLAST is as detailed on:
# https://www.ncbi.nlm.nih.gov/books/NBK279675/
# In this case, we used: '10 sscinames std'
# 10 means csv format
# sscinames means unique Subject Scientific Name(s), separated by a ';'
# std means the standard set of result columns, which are:
# 'qseqid sseqid pident length mismatch
# gapopen qstart qend sstart send evalue bitscore',


# this function takes as input a quoted path to a BLAST result file
# and produces as output a dataframe with proper column headers
# and the 'qseqid' column split into sample and seq number
read_blast_output <- function(filename) {
  data_in <- read.csv(filename,
                      header = FALSE, # files don't have column names in them
                      col.names = c("sscinames", # unique Subject Sci Name(s)
                                    "qseqid",    # Query Seq-id
                                    "sseqid",    # Subject Seq-id
                                    "pident",    # Percntge of identical matches
                                    "length",    # Alignment length
                                    "mismatch",  # Number of mismatches
                                    "gapopen",   # Number of gap openings
                                    "qstart",    # Start of alignment in query
                                    "qend",      # End of alignment in query
                                    "sstart",    # Start of alignment in subj
                                    "send",      # End of alignment in subject
                                    "evalue",    # Expect value
                                    "bitscore"))  # Bit score

  # Next we want to split the query sequence ID into
  # Sample and Number components so we can group by sample
  # They originally look like "ERR1942280.1"
  # and we want to split that into two columns: "ERR1942280" and "1"
  # we can use the separate() function from the tidyr library to do this
  # Note that we have to double escape the period for this to work
  # the syntax is
  # separate(column_to_separate,
  # c("New_column_name_1", "New_column_name_2"),
  # "seperator")
  data_in <- data_in %>%
    separate(qseqid, c("sample_name", "sample_number"), "\\.")
}
```

```{r read-in-BLAST-data}
# this makes a vector of all the BLAST output file names, including
# the name(s) of the directories they are in
files_to_read_in <- list.files(path = "output/blast",
                               full.names = TRUE)

# We need to create an empty matrix with the right number of columns
# so that we can rbind() each dataset on to it
joined_blast_data <- matrix(nrow = 0,
                            ncol = 14)

# now we loop over each of the files in the list and append them
# to the bottom of the 'joined_blast_data' object
# we do this with the rbind() function and the function we
# made earlier to read in the files, read_blast_output()
for (filename in files_to_read_in) {
  joined_blast_data <- rbind(joined_blast_data,
                             read_blast_output(filename))
}
```

```{r read-in-metadata-and-join}
# Next we want to read in the metadata file so we can add that in too
# This is not a csv file, so we have to use a slightly different syntax
# here the `sep = "\t"` tells the function that the data are tab-delimited
# and the `stringsAsFactors = FALSE` tells it not to assume that things are
# categorical variables
metadata_in <- read.table(paste0("data/metadata/",
                                 "fierer_forensic_hand_mouse_SraRunTable.txt"),
                          sep = "\t",
                          header = TRUE,
                          stringsAsFactors = FALSE)

# Finally we use the left_join() function from dplyr to merge or 'join' the
# combined data and metadata into one big table, so it's easier to work with
# in R the `by = c("Run_s" = "sample_name")` syntax tells R which columns
# to match up when joining the datasets together
joined_blast_data_metadata <- metadata_in %>%
  left_join(joined_blast_data,
            by = c("Run_s" = "sample_name"))
```

```{r}
#Different bacterial taxa on male vs female hands
joined_blast_data_metadata %>%
  group_by(sscinames, sex_s) %>%
  tally() %>%
  arrange(desc(n)) %>%
  filter(sex_s != "Not applicable") %>%
  filter(n > 100) %>%
  ggplot(aes(sscinames, y = n, fill = sex_s)) +
  geom_col() +
  theme(axis.text = element_text(angle = 90,
                                 hjust = 1)) +
  ggtitle("Number of most abundant taxa in male vs female hands")

```



```{r}
#Abundance of Acidovorax sp. in male vs female hands

joined_blast_data_metadata %>%
  group_by(sscinames, sex_s) %>%
  tally() %>%
  arrange(desc(n)) %>%
  filter(sex_s != "Not applicable") %>%
  filter(n > 100) %>%
  filter(sscinames == "Acidovorax sp.") %>%
  ggplot(aes(sscinames, y = n, fill = sex_s)) +
  geom_col() +
  theme(axis.text = element_text(angle = 90,
                                 hjust = 1)) +
    ggtitle("Abundance of Acidovorax sp. in male vs female hands")
```







```{r show-levels}
levels(factor(joined_blast_data_metadata$anonymized_name_s))
```


```{r group-by-summarize}
#group by anonymized name and calculate mean percent identity
joined_blast_data_metadata %>%
  group_by(anonymized_name_s) %>%
  summarize(mean_pident = mean(pident),
            sd_pident = sd(pident)) %>%
  ggplot(aes(x = anonymized_name_s,
             y = mean_pident)) +
  geom_col(fill = "dodger blue") +
  geom_errorbar(aes(ymax = mean_pident + sd_pident,
                    ymin = mean_pident - sd_pident),
                width = 0.3) +
theme(axis.text.x = element_text(angle = 90,
                                    hjust = 1))

```


```{r histograms}
# Here we're using the dplyr piping syntax to select a subset of rows matching a
# criteria we specify (using the filter) function, and then pull out a column
# from the data to make a histogram.
joined_blast_data_metadata %>%
  filter(env_material_s == "dust") %>%
  filter(grepl("F2", host_subject_id_s)) %>%
  ggplot(aes(x = pident)) +
    geom_histogram() +
    ggtitle("Percent Identity") +
    xlab("Percent")
```


```{r counting-rows}
joined_blast_data_metadata %>%
  group_by(sscinames, env_material_s) %>%
  tally() %>%
  arrange(desc(n)) %>%
  filter(n > 300) %>%
  ggplot(aes(x = sscinames, 
             y = n,
             fill = env_material_s)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90,
                                   hjust =1))
```



```{r dplyr-example-1}
# using select() to extract particular columns of data
joined_blast_data_metadata %>%
  select(Organism_s, AvgSpotLen_l)

#use filter() to extract only certain rows that match a condition
joined_blast_data_metadata %>%
  filter(env_material_s == "dust")
 


```


Don't forget to report what your figures show in words, here in the Results section.

```{r summary-table}
# Finally, we'd like to be able to make a summary table of the counts of
# sequences for each subject for both sample types. To do that we can use the
# table() function. We add the kable() function as well (from the tidyr package)
# in order to format the table nicely when the document is knitted
kable(table(joined_blast_data_metadata$host_subject_id_s,
            joined_blast_data_metadata$sample_type_s))
```

# Discussion

Add 2-3 paragraphs here interpreting your results and considering future directions one might take in analyzing these data.

